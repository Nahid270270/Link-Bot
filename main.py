import asyncio
import re
import urllib.parse
from datetime import datetime

from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from rapidfuzz import process, fuzz
from pymongo import MongoClient

# ====== CONFIGURATION ======
API_ID = 1234567  # ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ API_ID
API_HASH = "your_api_hash"  # ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ API_HASH
BOT_TOKEN = "your_bot_token"  # ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶¨‡¶ü ‡¶ü‡ßã‡¶ï‡ßá‡¶®

CHANNEL_ID = -1001234567890  # ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤‡ßá‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø (‡¶Ø‡ßá‡¶ñ‡¶æ‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶Ü‡¶∏‡¶¨‡ßá)

MONGO_URI = "mongodb://localhost:27017"  # MongoDB URI
DB_NAME = "moviebotdb"
MOVIES_COLLECTION = "movies"
USERS_COLLECTION = "users"

ADMIN_IDS = [123456789, 987654321]  # ‡¶§‡ßã‡¶Æ‡¶æ‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶≤‡¶ø‡¶∏‡ßç‡¶ü

RESULTS_COUNT = 10  # ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö ‡¶ï‡¶§‡¶ó‡ßÅ‡¶≤‡ßã ‡¶∏‡¶æ‡¶ú‡ßá‡¶∂‡¶® ‡¶¶‡ßá‡¶ñ‡¶æ‡¶¨‡ßá

# ===========================

app = Client("moviebot", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)

mongo_client = MongoClient(MONGO_URI)
db = mongo_client[DB_NAME]
movies_col = db[MOVIES_COLLECTION]
users_col = db[USERS_COLLECTION]

# Helper: Clean text for search
def clean_text(text):
    return re.sub(r"[^a-zA-Z0-9\s]", "", text).strip().lower()

# Helper: Delete message later (10 seconds)
async def delete_message_later(chat_id, message_id, delay=10):
    await asyncio.sleep(delay)
    try:
        await app.delete_messages(chat_id, message_id)
    except Exception:
        pass

# --- DEBUG: log all incoming messages ---
@app.on_message()
async def debug_all_messages(client, message):
    print(f"[DEBUG] Incoming message: {message.text if message.text else 'No text'} from user {message.from_user.id if message.from_user else 'unknown'}")

# --- Main search handler ---
@app.on_message(filters.text & ~filters.private)
async def search(_, msg):
    print(f"[DEBUG] Received message from user_id={msg.from_user.id if msg.from_user else 'unknown'}: {msg.text}")
    try:
        raw_query = msg.text.strip()
        if len(raw_query) < 3:
            return await msg.reply("‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ü‡¶∞‡¶ì ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü ‡¶è‡¶ï‡¶ü‡¶ø ‡¶®‡¶æ‡¶Æ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® (‡¶ï‡¶Æ‡¶™‡¶ï‡ßç‡¶∑‡ßá ‡ß© ‡¶Ö‡¶ï‡ßç‡¶∑‡¶∞)‡•§")

        query = clean_text(raw_query)
        users_col.update_one(
            {"_id": msg.from_user.id},
            {"$set": {"last_search": datetime.utcnow()}},
            upsert=True
        )

        loading = await msg.reply("üîé ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá, ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®...")

        all_movies = list(movies_col.find({}, {"title": 1, "message_id": 1, "language": 1}))

        movie_titles = [m["title"] for m in all_movies]
        matched = process.extract(raw_query, movie_titles, scorer=fuzz.partial_ratio, limit=RESULTS_COUNT)
        matched_titles = [match[0] for match in matched if match[1] >= 50]
        suggestions = [m for m in all_movies if m["title"] in matched_titles]

        if suggestions:
            await loading.delete()
            lang_buttons = [
                InlineKeyboardButton("Bengali", callback_data=f"lang_Bengali_{query}"),
                InlineKeyboardButton("Hindi", callback_data=f"lang_Hindi_{query}"),
                InlineKeyboardButton("English", callback_data=f"lang_English_{query}")
            ]
            buttons = [
                [InlineKeyboardButton(m["title"][:40], callback_data=f"movie_{m['message_id']}")]
                for m in suggestions[:RESULTS_COUNT]
            ]
            buttons.append(lang_buttons)
            m = await msg.reply("‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶∞ ‡¶®‡¶æ‡¶Æ ‡¶Æ‡¶ø‡¶≤‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá, ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®:", reply_markup=InlineKeyboardMarkup(buttons))
            asyncio.create_task(delete_message_later(m.chat.id, m.id))
            return

        await loading.delete()
        google_search_url = "https://www.google.com/search?q=" + urllib.parse.quote(raw_query)
        google_button = InlineKeyboardMarkup([
            [InlineKeyboardButton("Search on Google", url=google_search_url)]
        ])
        alert = await msg.reply(
            "‡¶ï‡ßã‡¶®‡¶ì ‡¶´‡¶≤‡¶æ‡¶´‡¶≤ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡¶ï‡ßá ‡¶ú‡¶æ‡¶®‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§ ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶ó‡ßÅ‡¶ó‡¶≤‡ßá ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
            reply_markup=google_button
        )
        asyncio.create_task(delete_message_later(alert.chat.id, alert.id))

        btn = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("‚úÖ ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶Ü‡¶õ‡ßá", callback_data=f"has_{msg.chat.id}_{msg.id}_{raw_query}"),
                InlineKeyboardButton("‚ùå ‡¶®‡ßá‡¶á", callback_data=f"no_{msg.chat.id}_{msg.id}_{raw_query}")
            ],
            [
                InlineKeyboardButton("‚è≥ ‡¶Ü‡¶∏‡¶¨‡ßá", callback_data=f"soon_{msg.chat.id}_{msg.id}_{raw_query}"),
                InlineKeyboardButton("‚úèÔ∏è ‡¶≠‡ßÅ‡¶≤ ‡¶®‡¶æ‡¶Æ", callback_data=f"wrong_{msg.chat.id}_{msg.id}_{raw_query}")
            ]
        ])
        for admin_id in ADMIN_IDS:
            await app.send_message(
                admin_id,
                f"‚ùó ‡¶á‡¶â‡¶ú‡¶æ‡¶∞ `{msg.from_user.id}` `{msg.from_user.first_name}` ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá‡¶õ‡ßá: **{raw_query}**\n‡¶´‡¶≤‡¶æ‡¶´‡¶≤ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§ ‡¶®‡¶ø‡¶ö‡ßá ‡¶¨‡¶æ‡¶ü‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶®‡•§",
                reply_markup=btn
            )
    except Exception as e:
        print(f"[ERROR] Exception in search handler: {e}")
        await msg.reply("‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö‡ßá‡¶∞ ‡¶∏‡¶Æ‡ßü ‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶ò‡¶ü‡ßá‡¶õ‡ßá‡•§")

# --- Callback query handler ---
@app.on_callback_query()
async def callback_handler(_, cq: CallbackQuery):
    print(f"[DEBUG] Callback query data: {cq.data} from user {cq.from_user.id if cq.from_user else 'unknown'}")
    data = cq.data

    if data.startswith("movie_"):
        try:
            mid = int(data.split("_")[1])
            fwd = await app.forward_messages(cq.message.chat.id, CHANNEL_ID, mid)
            asyncio.create_task(delete_message_later(cq.message.chat.id, fwd.id))
            await cq.answer("‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
        except Exception as e:
            print(f"[ERROR] Forwarding movie failed: {e}")
            await cq.answer("‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨ ‡¶π‡ßü‡¶®‡¶ø‡•§")

    elif data.startswith("lang_"):
        try:
            _, lang, query = data.split("_", 2)
            lang_movies = list(movies_col.find({"language": lang}))
            matches = [
                m for m in lang_movies
                if re.search(re.escape(query), m.get("title", ""), re.IGNORECASE)
            ]
            if matches:
                buttons = [
                    [InlineKeyboardButton(m["title"][:40], callback_data=f"movie_{m['message_id']}")]
                    for m in matches[:RESULTS_COUNT]
                ]
                await cq.message.edit_text(
                    f"‡¶´‡¶≤‡¶æ‡¶´‡¶≤ ({lang}) - ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®:",
                    reply_markup=InlineKeyboardMarkup(buttons)
                )
            else:
                await cq.answer("‡¶è‡¶á ‡¶≠‡¶æ‡¶∑‡¶æ‡¶Ø‡¶º ‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø‡•§", show_alert=True)
            await cq.answer()
        except Exception as e:
            print(f"[ERROR] Language filter error: {e}")
            await cq.answer("‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø ‡¶ò‡¶ü‡ßá‡¶õ‡ßá‡•§")

    elif "_" in data:
        parts = data.split("_", 3)
        if len(parts) == 4:
            action, uid, mid, raw_query = parts
            try:
                uid = int(uid)
                responses = {
                    "has": f"‚úÖ @{cq.from_user.username or cq.from_user.first_name} ‡¶ú‡¶æ‡¶®‡¶ø‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶® ‡¶Ø‡ßá **{raw_query}** ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶ü‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶ú‡ßá ‡¶Ü‡¶õ‡ßá‡•§ ‡¶∏‡¶†‡¶ø‡¶ï ‡¶®‡¶æ‡¶Æ ‡¶≤‡¶ø‡¶ñ‡ßá ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§",
                    "no": f"‚ùå @{cq.from_user.username or cq.from_user.first_name} ‡¶ú‡¶æ‡¶®‡¶ø‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶® ‡¶Ø‡ßá **{raw_query}** ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶ü‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶ú‡ßá ‡¶®‡ßá‡¶á‡•§",
                    "soon": f"‚è≥ @{cq.from_user.username or cq.from_user.first_name} ‡¶ú‡¶æ‡¶®‡¶ø‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶® ‡¶Ø‡ßá **{raw_query}** ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶ü‡¶ø ‡¶∂‡ßÄ‡¶ò‡ßç‡¶∞‡¶á ‡¶Ü‡¶∏‡¶¨‡ßá‡•§",
                    "wrong": f"‚úèÔ∏è @{cq.from_user.username or cq.from_user.first_name} ‡¶¨‡¶≤‡¶õ‡ßá‡¶® ‡¶Ø‡ßá ‡¶Ü‡¶™‡¶®‡¶ø ‡¶≠‡ßÅ‡¶≤ ‡¶®‡¶æ‡¶Æ ‡¶≤‡¶ø‡¶ñ‡ßá‡¶õ‡ßá‡¶®: **{raw_query}**‡•§"
                }
                if action in responses:
                    m = await app.send_message(uid, responses[action])
                    asyncio.create_task(delete_message_later(m.chat.id, m.id))
                    await cq.answer("‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡ßá‡¶∞ ‡¶™‡¶ï‡ßç‡¶∑ ‡¶•‡ßá‡¶ï‡ßá ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
                else:
                    await cq.answer()
            except Exception as e:
                print(f"[ERROR] Admin reply error: {e}")
                await cq.answer()

# --- Start the bot ---
print("Bot is starting...")
app.run()
